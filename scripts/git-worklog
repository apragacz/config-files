#!/usr/bin/env python
import subprocess
import sys
import collections
import re
import datetime

from functools import partial

Event = collections.namedtuple('Event',
                               ('commit_hash',
                                'author_email',
                                'datetime',
                                'ticket',
                                'comment'))

GIT_EMAIL_FILENAME = '.git/AUTHOR_EMAIL'
JIRA_PROJECT_FILENAME = '.git/JIRA_PROJECT'


def compose(*args):
    return reduce(lambda g, f: (lambda elem: f(g(elem))), reversed(args))


def identity(elem):
    return elem


def ilimit(iterable, limit=100, offset=0):
    end_offset = offset + limit
    for i, elem in enumerate(iterable):
        if offset <= i and i < end_offset:
            yield elem
        elif end_offset <= i:
            return


def pretty_form(event):
    return '{}'.format(event.comment)


def pretty_form_tuple(event_group):
    ticket = event_group[0].ticket if event_group[0].ticket else '<Unknown>'
    datetime_start = event_group[0].datetime
    datetime_end = event_group[-1].datetime
    return '\n{} {}-{}\n\n{}\n'.format(ticket, datetime_start, datetime_end,
                                       '\n'.join(map(pretty_form,
                                                     event_group)))


def add_to_event_group(event_groups, event, equiv_pred):
    last_group = event_groups[-1] if len(event_groups) > 0 else ()
    if not last_group:
        return event_groups[:-1] + [(event,)]
    elif equiv_pred(last_group[0], event):
        return event_groups[:-1] + [last_group + (event,)]
    else:
        return event_groups + [(event,)]


def group_events(events):
    return reduce(partial(add_to_event_group,
                          equiv_pred=partial(equivalence_by_key,
                                             key=lambda e: e. ticket)),
                  events, [])


def event_from_gitlog(line, project_name):
    sp = line.strip().split(' ', 3)
    commit_hash = sp[0]
    timestamp = int(sp[1])
    author_email = sp[2]
    full_comment = sp[3]
    comment_sp = full_comment.split(' ', 1)
    dt = datetime.datetime.fromtimestamp(timestamp)
    ticket_pat = '^({})\-[0-9]+$'.format(project_name)
    ticket_re = re.compile(ticket_pat)
    if ticket_re.search(comment_sp[0]):
        ticket = comment_sp[0]
        if len(comment_sp) == 2:
            comment = comment_sp[1]
        else:
            comment = None
    else:
        ticket = None
        comment = full_comment
    return Event(commit_hash=commit_hash,
            datetime=dt,
            ticket=ticket, comment=comment,
            author_email=author_email)


def equivalence_by_key(event1, event2, key):
    return key(event1) == key(event2)


def test_date(event, date):
    return event.datetime.date() == date


def test_email(event, email):
    return event.author_email == email


def content_of_filename(filename, default=None):
    try:
        with open(filename, 'rt') as f:
            return f.read().strip()
    except IOError:
        return None


def set_filename_content(filename, content):
    with open(filename, 'wt') as f:
        f.write(content)


def handle_set_project(project_name):
    set_filename_content(JIRA_PROJECT_FILENAME, project_name)
    print('project name set to {}'.format(project_name))


def handle_get_project():
    project_name = content_of_filename(JIRA_PROJECT_FILENAME)
    print('project name is {}'.format(project_name))


def handle_set_email(email):
    set_filename_content(GIT_EMAIL_FILENAME, email)
    print('email set to {}'.format(email))


def handle_get_email():
    email = content_of_filename(GIT_EMAIL_FILENAME)
    print('email is {}'.format(email))


def handle_day(date_string):
    date_sp = date_string.split('-', 2)
    email = content_of_filename(GIT_EMAIL_FILENAME)
    project_name = content_of_filename(JIRA_PROJECT_FILENAME)
    if email is None:
        print('no email set')
        return
    if project_name is None:
        print('no project name set')
        return
    current_date = datetime.date(int(date_sp[0]), int(date_sp[1]),
                                    int(date_sp[2]))
    p = subprocess.Popen(['git', 'log', '--format=%H %at %ae %s'],
                            stdin=subprocess.PIPE, stdout=subprocess.PIPE,
                            close_fds=True)
    p_out = p.stdout
    process = compose(partial(map, pretty_form_tuple),
                        group_events,
                        partial(sorted, key=lambda e: e.datetime),
                        partial(filter, partial(test_date, date=current_date)),
                        partial(filter, partial(test_email, email=email)),
                        partial(ilimit, limit=1000),
                        partial(map, partial(event_from_gitlog,
                                             project_name=project_name)))
    for result in process(p_out):
        print(result)
    p_out.close()


def main(args):
    cmd = args[1] if len(args) > 1 else None
    if cmd == 'set-email':
        handle_set_email(args[2])
    elif cmd == 'set-project':
        handle_set_project(args[2])
    elif cmd == 'get-email':
        handle_get_email()
    elif cmd == 'get-project':
        handle_get_project()
    elif cmd == 'day':
        handle_day(args[2])
    else:
        print('invalid command')


if __name__ == '__main__':
    main(sys.argv)
